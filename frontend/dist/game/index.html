<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
  <title>SNO — One-Tap Lane Runner</title>
  <style>
    :root {
      --bg: #0b1020;
      --fg: #e9ecf8;
      --brand: #6c4cff;
      --danger: #ff4d6d;
      --ok: #22c55e;
    }
    * { box-sizing: border-box; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap {
      position: relative;
      width: 100%;
      max-width: 420px;

      /* Три уровня фолбэков: кастомная --vh, новые единицы dvh/svh, и обычный vh */
      height: calc(var(--vh, 1vh) * 100);
      height: 100svh;        /* новые стабильные единицы */
      height: 100dvh;        /* ещё один фолбэк */
      margin: 0 auto;
      display: flex; flex-direction: column;
      -webkit-user-select: none; user-select: none;
      touch-action: pan-y;

      /* учитываем безопасную зону снизу (дом-индикатор) */
      padding-bottom: env(safe-area-inset-bottom);
    }
    .hud {
      display:flex; align-items:center; justify-content:space-between;
      gap: 8px; padding: 10px 12px;
      background: rgba(255,255,255,.06);
      border-bottom: 1px solid rgba(255,255,255,.08);
      font-weight: 700; letter-spacing: .2px;
    }
    .hud .badge { display:inline-flex; align-items:center; gap:6px; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; background: var(--brand); }
    .canvas-wrap { position: relative; flex: 1; }
    canvas { display:block; width:100%; height:100%; background: radial-gradient(1200px 800px at 50% -200px, #1a2040 0%, #0b1020 60%); }
    .overlay {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.35);
    }
    .panel {
      width: min(92%, 360px);
      background: #111630;
      border: 1px solid #252a4a;
      border-radius: 16px; padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      text-align:center;
    }
    .title { font-size: 20px; font-weight: 800; margin-bottom: 8px; }
    .muted { color: #9aa3c7; }
    .btn {
      margin-top: 12px; padding: 10px 14px; border-radius: 12px; border: 0;
      background: var(--brand); color:#fff; font-weight:800; cursor:pointer;
      transition: transform .06s ease, background .15s ease;
      width: 100%;
    }
    .btn:hover { background: #5438d6; }
    .btn:active { transform: translateY(1px); background: #4329b7; }
    .row { display:flex; align-items:center; justify-content:center; gap:8px; margin-top:8px; flex-wrap:wrap; }
    .pill { border-radius: 999px; padding: 6px 10px; background:#23284a; color:#cdd3f0; font-weight:700; font-size:13px; }
    .ok { color: var(--ok); } .bad { color: var(--danger); }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <div class="hud">
      <div class="badge"><span class="dot"></span> СЧЁТ: <span id="score">0</span></div>
      <div class="badge">⏱ <span id="time">00</span>s</div>
      <div class="badge">♥ <span id="life">3</span></div>
    </div>

    <div class="canvas-wrap">
      <canvas id="game"></canvas>

      <div class="overlay" id="overlay">
        <div class="panel" id="panel">
          <div class="title">Однокнопочный раннер</div>
          <div class="muted">Свайп влево/вправо — смена полосы. Собирай фиолетовые, избегай красных.</div>
          <div class="row">
            <span class="pill">Свайп: ← / →</span>
            <span class="pill">Клавиши: ← / →</span>
            <span class="pill">Тап: циклическая смена</span>
          </div>
          <button class="btn" id="startBtn">Играть</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const $ = s => document.querySelector(s);
    const wrap = $('#wrap');
    const canvas = $('#game');
    const ctx = canvas.getContext('2d');
    const scoreEl = $('#score');
    const timeEl = $('#time');
    const lifeEl = $('#life');
    const overlay = $('#overlay');
    const panel = $('#panel');
    const startBtn = $('#startBtn');

    // --- Resize / DPR ---
    function resize() {
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const w = wrap.clientWidth;
      const h = wrap.clientHeight - wrap.querySelector('.hud').offsetHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // --- Game state ---
    const state = {
      running: false,
      over: false,
      elapsed: 0,
      score: 0,
      life: 3,
      lanes: 3,
      laneIndex: 1,       // 0..2
      laneX: [],          // centers
      playerY: 0,
      playerR: 14,
      baseSpeed: 2.2,
      speed: 2.2,
      // Мягкий рост скорости (~ +1.2 за минуту):
      speedGrowth: 0.00002, // per ms
      lastSpawnObs: 0,
      lastSpawnOrb: 0,
      obs: [], // {lane, y, h, w}
      orbs: [], // {lane, y, r}
    };

    function reset() {
      state.running = false;
      state.over = false;
      state.elapsed = 0;
      state.score = 0;
      state.life = 3;
      state.baseSpeed = 2.2;
      state.speed = state.baseSpeed;
      state.lastSpawnObs = 0;
      state.lastSpawnOrb = 0;
      state.obs = [];
      state.orbs = [];

      // lanes
      const W = canvas.clientWidth;
      const padding = Math.max(12, Math.floor(W * 0.05));
      const trackW = W - padding * 2;
      const laneW = trackW / state.lanes;
      state.laneX = Array.from({ length: state.lanes }, (_, i) => Math.round(padding + laneW * i + laneW / 2));
      state.laneIndex = 1;

      // player baseline
      const H = canvas.clientHeight;
      state.playerY = H - Math.max(64, Math.floor(H * 0.12));
      updateHUD();
    }

    function updateHUD() {
      scoreEl.textContent = state.score | 0;
      timeEl.textContent = String(Math.floor(state.elapsed / 1000)).padStart(2, '0');
      lifeEl.textContent = state.life;
    }

    // --- Input ---
    function changeLane(delta) {
      if (!state.running) return;
      const next = Math.max(0, Math.min(state.lanes - 1, state.laneIndex + delta));
      if (next !== state.laneIndex) state.laneIndex = next;
    }
    function nextLaneCycle() {
      if (!state.running) return;
      state.laneIndex = (state.laneIndex + 1) % state.lanes;
    }

    // Tap = циклическая смена
    canvas.addEventListener('click', nextLaneCycle, { passive: true });

    // Клавиатура: ← / → (и на всякий случай Space/↑ — как раньше)
    window.addEventListener('keydown', (e) => {
      if (!state.running) return;
      if (e.key === 'ArrowLeft') { e.preventDefault(); changeLane(-1); }
      else if (e.key === 'ArrowRight') { e.preventDefault(); changeLane(1); }
      else if (e.key === ' ' || e.key === 'ArrowUp') { e.preventDefault(); nextLaneCycle(); }
    }, { passive: false });

    // Свайпы по канвасу (горизонтальные)
    let touchStart = null;
    canvas.addEventListener('touchstart', (e) => {
      if (!state.running) return;
      const t = e.changedTouches[0];
      touchStart = { x: t.clientX, y: t.clientY, time: performance.now() };
    }, { passive: true });

    canvas.addEventListener('touchend', (e) => {
      if (!state.running || !touchStart) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      const dt = performance.now() - touchStart.time;

      // Порог: горизонтальный жест, ~ короткий (до 500мс), расстояние > 30px и |dx| > |dy|
      const DIST = 30;
      if (Math.abs(dx) > DIST && Math.abs(dx) > Math.abs(dy) && dt < 500) {
        if (dx > 0) changeLane(1); else changeLane(-1);
      }
      touchStart = null;
    }, { passive: true });

    // --- Spawning ---
    function spawnObstacle() {
      const lane = Math.floor(Math.random() * state.lanes);
      const W = 36; // ширина столбика
      const H = 18 + Math.random() * 26;
      state.obs.push({ lane, y: -H, w: W, h: H });
    }
    function spawnOrb() {
      const lane = Math.floor(Math.random() * state.lanes);
      state.orbs.push({ lane, y: -10, r: 8 });
    }

    // --- Loop ---
    let raf = 0, last = 0;
    function loop(t) {
      if (!state.running) return;
      raf = requestAnimationFrame(loop);
      const dt = Math.min(32, t - last || 16);
      last = t;

      state.elapsed += dt;
      updateHUD();

      // Мягкое ускорение
      state.speed += state.speedGrowth * dt;

      // Спавн медленнее нарастает: уменьшаем интервал плавнее
      const baseObs = 750; // мс (чуть реже по дефолту)
      const baseOrb = 1050; // мс
      const obsInterval = Math.max(360, baseObs - state.elapsed * 0.05); // −3 мс/сек
      const orbInterval = Math.max(600, baseOrb - state.elapsed * 0.03);  // −1.8 мс/сек

      if (t - state.lastSpawnObs > obsInterval) {
        spawnObstacle();
        state.lastSpawnObs = t;
      }
      if (t - state.lastSpawnOrb > orbInterval) {
        spawnOrb();
        state.lastSpawnOrb = t;
      }

      // Обновление позиций
      const s = state.speed;
      for (let i = state.obs.length - 1; i >= 0; i--) {
        const o = state.obs[i];
        o.y += s * 3.0;
        if (o.y > canvas.clientHeight + 40) state.obs.splice(i, 1);
      }
      for (let i = state.orbs.length - 1; i >= 0; i--) {
        const o = state.orbs[i];
        o.y += s * 2.6;
        if (o.y > canvas.clientHeight + 20) state.orbs.splice(i, 1);
      }

      // Коллизии
      const px = state.laneX[state.laneIndex];
      const py = state.playerY;

      // Орбы
      for (let i = state.orbs.length - 1; i >= 0; i--) {
        const o = state.orbs[i];
        if (o.lane === state.laneIndex && Math.abs(o.y - py) < state.playerR + o.r + 2) {
          state.orbs.splice(i, 1);
          state.score += 10;
          flash('#6c4cff');
        }
      }
      // Препятствия
      for (let i = state.obs.length - 1; i >= 0; i--) {
        const ob = state.obs[i];
        if (ob.lane === state.laneIndex) {
          const top = ob.y, bottom = ob.y + ob.h;
          if (py + state.playerR > top && py - state.playerR < bottom) {
            state.obs.splice(i, 1);
            state.life -= 1;
            flash('#ff4d6d');
            if (state.life <= 0) {
              gameOver();
              return;
            }
          }
        }
      }

      draw();
    }

    // --- Drawing ---
    function draw() {
      const W = canvas.clientWidth, H = canvas.clientHeight;
      ctx.clearRect(0, 0, W, H);

      // дорожки
      const padding = Math.max(12, Math.floor(W * 0.05));
      const trackW = W - padding * 2;
      const laneW = trackW / state.lanes;

      // фоновые полосы
      for (let i = 0; i < state.lanes; i++) {
        const x = padding + i * laneW;
        ctx.fillStyle = i % 2 ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.015)';
        ctx.fillRect(x, 0, laneW, H);
      }

      // разметка
      ctx.strokeStyle = 'rgba(255,255,255,.08)';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 14]);
      for (let i = 1; i < state.lanes; i++) {
        const x = padding + i * laneW;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // орбы
      for (const o of state.orbs) {
        const cx = state.laneX[o.lane];
        ctx.beginPath();
        ctx.arc(cx, o.y, o.r, 0, Math.PI * 2);
        ctx.fillStyle = '#6c4cff';
        ctx.shadowColor = '#6c4cff';
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // препятствия
      for (const ob of state.obs) {
        const cx = state.laneX[ob.lane];
        const x = cx - ob.w / 2;
        ctx.fillStyle = '#ff4d6d';
        ctx.fillRect(x, ob.y, ob.w, ob.h);
        ctx.fillStyle = 'rgba(0,0,0,.2)';
        ctx.fillRect(x, ob.y, ob.w, 4);
      }

      // игрок
      const px = state.laneX[state.laneIndex];
      const py = state.playerY;
      ctx.beginPath();
      ctx.arc(px, py, state.playerR, 0, Math.PI * 2);
      ctx.fillStyle = '#e9ecf8';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#6c4cff';
      ctx.stroke();
    }

    // --- Flash effect ---
    function flash(color) {
      const overlay = document.createElement('div');
      overlay.style.position = 'absolute';
      overlay.style.inset = '0';
      overlay.style.background = color;
      overlay.style.opacity = '0.18';
      overlay.style.pointerEvents = 'none';
      overlay.style.transition = 'opacity .22s ease';
      canvas.parentElement.appendChild(overlay);
      requestAnimationFrame(() => overlay.style.opacity = '0');
      setTimeout(() => overlay.remove(), 220);
    }

    // --- Lifecycle ---
    function start() {
      reset();
      overlay.style.display = 'none';
      state.running = true;
      last = performance.now();
      raf = requestAnimationFrame(loop);
    }
    function stop() {
      state.running = false;
      cancelAnimationFrame(raf);
    }
    function gameOver() {
      stop();
      state.over = true;
      panel.innerHTML = `
        <div class="title">Игра окончена</div>
        <div class="muted">Счёт: <b>${state.score}</b>, время: <b>${Math.floor(state.elapsed/1000)}s</b></div>
        <div class="row">
          <span class="pill ok">+${state.score}</span>
          <span class="pill">жизни: 0</span>
        </div>
        <button class="btn" id="againBtn">Играть снова</button>
      `;
      overlay.style.display = 'flex';
      const again = document.getElementById('againBtn');
      again?.addEventListener('click', () => start());

      try {
        window.parent && window.parent.postMessage({ type: 'GAME_OVER', score: state.score }, '*');
      } catch {}
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden && state.running) stop();
    });

    startBtn.addEventListener('click', start);
  })();
  </script>
  <script>
    // Правильная высота для WebView/Telegram/iOS (без чёрной плашки)
    function setVH() {
      const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    setVH();
    window.addEventListener('resize', setVH);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', setVH);
    }
</script>
</body>
</html>
